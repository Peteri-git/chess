// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GameService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GameService_2eproto;
namespace GrpcGameService {
class GameCommandResponse;
class GameCommandResponseDefaultTypeInternal;
extern GameCommandResponseDefaultTypeInternal _GameCommandResponse_default_instance_;
class GameEnd;
class GameEndDefaultTypeInternal;
extern GameEndDefaultTypeInternal _GameEnd_default_instance_;
class GameMove;
class GameMoveDefaultTypeInternal;
extern GameMoveDefaultTypeInternal _GameMove_default_instance_;
class GameMoveRequest;
class GameMoveRequestDefaultTypeInternal;
extern GameMoveRequestDefaultTypeInternal _GameMoveRequest_default_instance_;
class GameMoveResponse;
class GameMoveResponseDefaultTypeInternal;
extern GameMoveResponseDefaultTypeInternal _GameMoveResponse_default_instance_;
class GameStart;
class GameStartDefaultTypeInternal;
extern GameStartDefaultTypeInternal _GameStart_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class GameTile;
class GameTileDefaultTypeInternal;
extern GameTileDefaultTypeInternal _GameTile_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Room;
class RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
class RoomCreateRequest;
class RoomCreateRequestDefaultTypeInternal;
extern RoomCreateRequestDefaultTypeInternal _RoomCreateRequest_default_instance_;
class RoomCreateResponse;
class RoomCreateResponseDefaultTypeInternal;
extern RoomCreateResponseDefaultTypeInternal _RoomCreateResponse_default_instance_;
class RoomJoinRequest;
class RoomJoinRequestDefaultTypeInternal;
extern RoomJoinRequestDefaultTypeInternal _RoomJoinRequest_default_instance_;
class RoomListRequest;
class RoomListRequestDefaultTypeInternal;
extern RoomListRequestDefaultTypeInternal _RoomListRequest_default_instance_;
class RoomListResponse;
class RoomListResponseDefaultTypeInternal;
extern RoomListResponseDefaultTypeInternal _RoomListResponse_default_instance_;
}  // namespace GrpcGameService
PROTOBUF_NAMESPACE_OPEN
template<> ::GrpcGameService::GameCommandResponse* Arena::CreateMaybeMessage<::GrpcGameService::GameCommandResponse>(Arena*);
template<> ::GrpcGameService::GameEnd* Arena::CreateMaybeMessage<::GrpcGameService::GameEnd>(Arena*);
template<> ::GrpcGameService::GameMove* Arena::CreateMaybeMessage<::GrpcGameService::GameMove>(Arena*);
template<> ::GrpcGameService::GameMoveRequest* Arena::CreateMaybeMessage<::GrpcGameService::GameMoveRequest>(Arena*);
template<> ::GrpcGameService::GameMoveResponse* Arena::CreateMaybeMessage<::GrpcGameService::GameMoveResponse>(Arena*);
template<> ::GrpcGameService::GameStart* Arena::CreateMaybeMessage<::GrpcGameService::GameStart>(Arena*);
template<> ::GrpcGameService::GameState* Arena::CreateMaybeMessage<::GrpcGameService::GameState>(Arena*);
template<> ::GrpcGameService::GameTile* Arena::CreateMaybeMessage<::GrpcGameService::GameTile>(Arena*);
template<> ::GrpcGameService::Position* Arena::CreateMaybeMessage<::GrpcGameService::Position>(Arena*);
template<> ::GrpcGameService::Room* Arena::CreateMaybeMessage<::GrpcGameService::Room>(Arena*);
template<> ::GrpcGameService::RoomCreateRequest* Arena::CreateMaybeMessage<::GrpcGameService::RoomCreateRequest>(Arena*);
template<> ::GrpcGameService::RoomCreateResponse* Arena::CreateMaybeMessage<::GrpcGameService::RoomCreateResponse>(Arena*);
template<> ::GrpcGameService::RoomJoinRequest* Arena::CreateMaybeMessage<::GrpcGameService::RoomJoinRequest>(Arena*);
template<> ::GrpcGameService::RoomListRequest* Arena::CreateMaybeMessage<::GrpcGameService::RoomListRequest>(Arena*);
template<> ::GrpcGameService::RoomListResponse* Arena::CreateMaybeMessage<::GrpcGameService::RoomListResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace GrpcGameService {

enum Color : int {
  NONE = 0,
  WHITE = 1,
  BLACK = 2,
  Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Color_IsValid(int value);
constexpr Color Color_MIN = NONE;
constexpr Color Color_MAX = BLACK;
constexpr int Color_ARRAYSIZE = Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_descriptor();
template<typename T>
inline const std::string& Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Color_descriptor(), enum_t_value);
}
inline bool Color_Parse(
    const std::string& name, Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Color>(
    Color_descriptor(), name, value);
}
enum Figurine : int {
  None = 0,
  King = 1,
  Queen = 2,
  Rook = 3,
  Knight = 4,
  Bishop = 5,
  Pawn = 6,
  Figurine_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Figurine_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Figurine_IsValid(int value);
constexpr Figurine Figurine_MIN = None;
constexpr Figurine Figurine_MAX = Pawn;
constexpr int Figurine_ARRAYSIZE = Figurine_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Figurine_descriptor();
template<typename T>
inline const std::string& Figurine_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Figurine>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Figurine_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Figurine_descriptor(), enum_t_value);
}
inline bool Figurine_Parse(
    const std::string& name, Figurine* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Figurine>(
    Figurine_descriptor(), name, value);
}
// ===================================================================

class RoomListRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.RoomListRequest) */ {
 public:
  RoomListRequest();
  virtual ~RoomListRequest();

  RoomListRequest(const RoomListRequest& from);
  RoomListRequest(RoomListRequest&& from) noexcept
    : RoomListRequest() {
    *this = ::std::move(from);
  }

  inline RoomListRequest& operator=(const RoomListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomListRequest& operator=(RoomListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomListRequest* internal_default_instance() {
    return reinterpret_cast<const RoomListRequest*>(
               &_RoomListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoomListRequest& a, RoomListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomListRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomListRequest* New() const final {
    return CreateMaybeMessage<RoomListRequest>(nullptr);
  }

  RoomListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomListRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomListRequest& from);
  void MergeFrom(const RoomListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.RoomListRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GrpcGameService.RoomListRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class RoomListResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.RoomListResponse) */ {
 public:
  RoomListResponse();
  virtual ~RoomListResponse();

  RoomListResponse(const RoomListResponse& from);
  RoomListResponse(RoomListResponse&& from) noexcept
    : RoomListResponse() {
    *this = ::std::move(from);
  }

  inline RoomListResponse& operator=(const RoomListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomListResponse& operator=(RoomListResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomListResponse* internal_default_instance() {
    return reinterpret_cast<const RoomListResponse*>(
               &_RoomListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoomListResponse& a, RoomListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomListResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomListResponse* New() const final {
    return CreateMaybeMessage<RoomListResponse>(nullptr);
  }

  RoomListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomListResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomListResponse& from);
  void MergeFrom(const RoomListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.RoomListResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .GrpcGameService.Room rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::GrpcGameService::Room* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::Room >*
      mutable_rooms();
  private:
  const ::GrpcGameService::Room& _internal_rooms(int index) const;
  ::GrpcGameService::Room* _internal_add_rooms();
  public:
  const ::GrpcGameService::Room& rooms(int index) const;
  ::GrpcGameService::Room* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::Room >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:GrpcGameService.RoomListResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::Room > rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.RoomCreateRequest) */ {
 public:
  RoomCreateRequest();
  virtual ~RoomCreateRequest();

  RoomCreateRequest(const RoomCreateRequest& from);
  RoomCreateRequest(RoomCreateRequest&& from) noexcept
    : RoomCreateRequest() {
    *this = ::std::move(from);
  }

  inline RoomCreateRequest& operator=(const RoomCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateRequest& operator=(RoomCreateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomCreateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomCreateRequest* internal_default_instance() {
    return reinterpret_cast<const RoomCreateRequest*>(
               &_RoomCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoomCreateRequest& a, RoomCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomCreateRequest* New() const final {
    return CreateMaybeMessage<RoomCreateRequest>(nullptr);
  }

  RoomCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomCreateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomCreateRequest& from);
  void MergeFrom(const RoomCreateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.RoomCreateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.RoomCreateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class RoomCreateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.RoomCreateResponse) */ {
 public:
  RoomCreateResponse();
  virtual ~RoomCreateResponse();

  RoomCreateResponse(const RoomCreateResponse& from);
  RoomCreateResponse(RoomCreateResponse&& from) noexcept
    : RoomCreateResponse() {
    *this = ::std::move(from);
  }

  inline RoomCreateResponse& operator=(const RoomCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCreateResponse& operator=(RoomCreateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomCreateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomCreateResponse* internal_default_instance() {
    return reinterpret_cast<const RoomCreateResponse*>(
               &_RoomCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomCreateResponse& a, RoomCreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCreateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomCreateResponse* New() const final {
    return CreateMaybeMessage<RoomCreateResponse>(nullptr);
  }

  RoomCreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomCreateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomCreateResponse& from);
  void MergeFrom(const RoomCreateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCreateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.RoomCreateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .GrpcGameService.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::GrpcGameService::Room& room() const;
  ::GrpcGameService::Room* release_room();
  ::GrpcGameService::Room* mutable_room();
  void set_allocated_room(::GrpcGameService::Room* room);
  private:
  const ::GrpcGameService::Room& _internal_room() const;
  ::GrpcGameService::Room* _internal_mutable_room();
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.RoomCreateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::GrpcGameService::Room* room_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class RoomJoinRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.RoomJoinRequest) */ {
 public:
  RoomJoinRequest();
  virtual ~RoomJoinRequest();

  RoomJoinRequest(const RoomJoinRequest& from);
  RoomJoinRequest(RoomJoinRequest&& from) noexcept
    : RoomJoinRequest() {
    *this = ::std::move(from);
  }

  inline RoomJoinRequest& operator=(const RoomJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomJoinRequest& operator=(RoomJoinRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomJoinRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomJoinRequest* internal_default_instance() {
    return reinterpret_cast<const RoomJoinRequest*>(
               &_RoomJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoomJoinRequest& a, RoomJoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomJoinRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomJoinRequest* New() const final {
    return CreateMaybeMessage<RoomJoinRequest>(nullptr);
  }

  RoomJoinRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomJoinRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomJoinRequest& from);
  void MergeFrom(const RoomJoinRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomJoinRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.RoomJoinRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .GrpcGameService.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::GrpcGameService::Room& room() const;
  ::GrpcGameService::Room* release_room();
  ::GrpcGameService::Room* mutable_room();
  void set_allocated_room(::GrpcGameService::Room* room);
  private:
  const ::GrpcGameService::Room& _internal_room() const;
  ::GrpcGameService::Room* _internal_mutable_room();
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.RoomJoinRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::GrpcGameService::Room* room_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameMoveRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameMoveRequest) */ {
 public:
  GameMoveRequest();
  virtual ~GameMoveRequest();

  GameMoveRequest(const GameMoveRequest& from);
  GameMoveRequest(GameMoveRequest&& from) noexcept
    : GameMoveRequest() {
    *this = ::std::move(from);
  }

  inline GameMoveRequest& operator=(const GameMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMoveRequest& operator=(GameMoveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMoveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMoveRequest* internal_default_instance() {
    return reinterpret_cast<const GameMoveRequest*>(
               &_GameMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameMoveRequest& a, GameMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMoveRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMoveRequest* New() const final {
    return CreateMaybeMessage<GameMoveRequest>(nullptr);
  }

  GameMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMoveRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMoveRequest& from);
  void MergeFrom(const GameMoveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameMoveRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 2,
    kMoveFieldNumber = 1,
  };
  // string gameId = 2;
  void clear_gameid();
  const std::string& gameid() const;
  void set_gameid(const std::string& value);
  void set_gameid(std::string&& value);
  void set_gameid(const char* value);
  void set_gameid(const char* value, size_t size);
  std::string* mutable_gameid();
  std::string* release_gameid();
  void set_allocated_gameid(std::string* gameid);
  private:
  const std::string& _internal_gameid() const;
  void _internal_set_gameid(const std::string& value);
  std::string* _internal_mutable_gameid();
  public:

  // .GrpcGameService.GameMove move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::GrpcGameService::GameMove& move() const;
  ::GrpcGameService::GameMove* release_move();
  ::GrpcGameService::GameMove* mutable_move();
  void set_allocated_move(::GrpcGameService::GameMove* move);
  private:
  const ::GrpcGameService::GameMove& _internal_move() const;
  ::GrpcGameService::GameMove* _internal_mutable_move();
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameMoveRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameid_;
  ::GrpcGameService::GameMove* move_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameMoveResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameMoveResponse) */ {
 public:
  GameMoveResponse();
  virtual ~GameMoveResponse();

  GameMoveResponse(const GameMoveResponse& from);
  GameMoveResponse(GameMoveResponse&& from) noexcept
    : GameMoveResponse() {
    *this = ::std::move(from);
  }

  inline GameMoveResponse& operator=(const GameMoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMoveResponse& operator=(GameMoveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMoveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMoveResponse* internal_default_instance() {
    return reinterpret_cast<const GameMoveResponse*>(
               &_GameMoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameMoveResponse& a, GameMoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMoveResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMoveResponse* New() const final {
    return CreateMaybeMessage<GameMoveResponse>(nullptr);
  }

  GameMoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMoveResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMoveResponse& from);
  void MergeFrom(const GameMoveResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMoveResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameMoveResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameMoveResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool valid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameCommandResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameCommandResponse) */ {
 public:
  GameCommandResponse();
  virtual ~GameCommandResponse();

  GameCommandResponse(const GameCommandResponse& from);
  GameCommandResponse(GameCommandResponse&& from) noexcept
    : GameCommandResponse() {
    *this = ::std::move(from);
  }

  inline GameCommandResponse& operator=(const GameCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameCommandResponse& operator=(GameCommandResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameCommandResponse& default_instance();

  enum CommandsCase {
    kMove = 1,
    kStart = 2,
    kEnd = 3,
    COMMANDS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameCommandResponse* internal_default_instance() {
    return reinterpret_cast<const GameCommandResponse*>(
               &_GameCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GameCommandResponse& a, GameCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GameCommandResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameCommandResponse* New() const final {
    return CreateMaybeMessage<GameCommandResponse>(nullptr);
  }

  GameCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameCommandResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameCommandResponse& from);
  void MergeFrom(const GameCommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameCommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameCommandResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // .GrpcGameService.GameMove move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::GrpcGameService::GameMove& move() const;
  ::GrpcGameService::GameMove* release_move();
  ::GrpcGameService::GameMove* mutable_move();
  void set_allocated_move(::GrpcGameService::GameMove* move);
  private:
  const ::GrpcGameService::GameMove& _internal_move() const;
  ::GrpcGameService::GameMove* _internal_mutable_move();
  public:

  // .GrpcGameService.GameStart start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::GrpcGameService::GameStart& start() const;
  ::GrpcGameService::GameStart* release_start();
  ::GrpcGameService::GameStart* mutable_start();
  void set_allocated_start(::GrpcGameService::GameStart* start);
  private:
  const ::GrpcGameService::GameStart& _internal_start() const;
  ::GrpcGameService::GameStart* _internal_mutable_start();
  public:

  // .GrpcGameService.GameEnd end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::GrpcGameService::GameEnd& end() const;
  ::GrpcGameService::GameEnd* release_end();
  ::GrpcGameService::GameEnd* mutable_end();
  void set_allocated_end(::GrpcGameService::GameEnd* end);
  private:
  const ::GrpcGameService::GameEnd& _internal_end() const;
  ::GrpcGameService::GameEnd* _internal_mutable_end();
  public:

  void clear_Commands();
  CommandsCase Commands_case() const;
  // @@protoc_insertion_point(class_scope:GrpcGameService.GameCommandResponse)
 private:
  class _Internal;
  void set_has_move();
  void set_has_start();
  void set_has_end();

  inline bool has_Commands() const;
  inline void clear_has_Commands();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union CommandsUnion {
    CommandsUnion() {}
    ::GrpcGameService::GameMove* move_;
    ::GrpcGameService::GameStart* start_;
    ::GrpcGameService::GameEnd* end_;
  } Commands_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Position :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.Position";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
    kRowFieldNumber = 2,
  };
  // int32 column = 1;
  void clear_column();
  ::PROTOBUF_NAMESPACE_ID::int32 column() const;
  void set_column(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_column() const;
  void _internal_set_column(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 row = 2;
  void clear_row();
  ::PROTOBUF_NAMESPACE_ID::int32 row() const;
  void set_row(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_row() const;
  void _internal_set_row(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.Position)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 column_;
  ::PROTOBUF_NAMESPACE_ID::int32 row_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameMove :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameMove) */ {
 public:
  GameMove();
  virtual ~GameMove();

  GameMove(const GameMove& from);
  GameMove(GameMove&& from) noexcept
    : GameMove() {
    *this = ::std::move(from);
  }

  inline GameMove& operator=(const GameMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMove& operator=(GameMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMove* internal_default_instance() {
    return reinterpret_cast<const GameMove*>(
               &_GameMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameMove& a, GameMove& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMove* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMove* New() const final {
    return CreateMaybeMessage<GameMove>(nullptr);
  }

  GameMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMove& from);
  void MergeFrom(const GameMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameMove";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // .GrpcGameService.Position from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::GrpcGameService::Position& from() const;
  ::GrpcGameService::Position* release_from();
  ::GrpcGameService::Position* mutable_from();
  void set_allocated_from(::GrpcGameService::Position* from);
  private:
  const ::GrpcGameService::Position& _internal_from() const;
  ::GrpcGameService::Position* _internal_mutable_from();
  public:

  // .GrpcGameService.Position to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::GrpcGameService::Position& to() const;
  ::GrpcGameService::Position* release_to();
  ::GrpcGameService::Position* mutable_to();
  void set_allocated_to(::GrpcGameService::Position* to);
  private:
  const ::GrpcGameService::Position& _internal_to() const;
  ::GrpcGameService::Position* _internal_mutable_to();
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameMove)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::GrpcGameService::Position* from_;
  ::GrpcGameService::Position* to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameTile :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameTile) */ {
 public:
  GameTile();
  virtual ~GameTile();

  GameTile(const GameTile& from);
  GameTile(GameTile&& from) noexcept
    : GameTile() {
    *this = ::std::move(from);
  }

  inline GameTile& operator=(const GameTile& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameTile& operator=(GameTile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameTile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameTile* internal_default_instance() {
    return reinterpret_cast<const GameTile*>(
               &_GameTile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameTile& a, GameTile& b) {
    a.Swap(&b);
  }
  inline void Swap(GameTile* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameTile* New() const final {
    return CreateMaybeMessage<GameTile>(nullptr);
  }

  GameTile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameTile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameTile& from);
  void MergeFrom(const GameTile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameTile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameTile";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kFigurineFieldNumber = 1,
    kFigurineColorFieldNumber = 2,
  };
  // .GrpcGameService.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::GrpcGameService::Position& position() const;
  ::GrpcGameService::Position* release_position();
  ::GrpcGameService::Position* mutable_position();
  void set_allocated_position(::GrpcGameService::Position* position);
  private:
  const ::GrpcGameService::Position& _internal_position() const;
  ::GrpcGameService::Position* _internal_mutable_position();
  public:

  // .GrpcGameService.Figurine figurine = 1;
  void clear_figurine();
  ::GrpcGameService::Figurine figurine() const;
  void set_figurine(::GrpcGameService::Figurine value);
  private:
  ::GrpcGameService::Figurine _internal_figurine() const;
  void _internal_set_figurine(::GrpcGameService::Figurine value);
  public:

  // .GrpcGameService.Color figurineColor = 2;
  void clear_figurinecolor();
  ::GrpcGameService::Color figurinecolor() const;
  void set_figurinecolor(::GrpcGameService::Color value);
  private:
  ::GrpcGameService::Color _internal_figurinecolor() const;
  void _internal_set_figurinecolor(::GrpcGameService::Color value);
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameTile)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::GrpcGameService::Position* position_;
  int figurine_;
  int figurinecolor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameState) */ {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(nullptr);
  }

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .GrpcGameService.GameTile tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::GrpcGameService::GameTile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::GameTile >*
      mutable_tiles();
  private:
  const ::GrpcGameService::GameTile& _internal_tiles(int index) const;
  ::GrpcGameService::GameTile* _internal_add_tiles();
  public:
  const ::GrpcGameService::GameTile& tiles(int index) const;
  ::GrpcGameService::GameTile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::GameTile >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::GameTile > tiles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameStart :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameStart) */ {
 public:
  GameStart();
  virtual ~GameStart();

  GameStart(const GameStart& from);
  GameStart(GameStart&& from) noexcept
    : GameStart() {
    *this = ::std::move(from);
  }

  inline GameStart& operator=(const GameStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStart& operator=(GameStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStart* internal_default_instance() {
    return reinterpret_cast<const GameStart*>(
               &_GameStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GameStart& a, GameStart& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStart* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameStart* New() const final {
    return CreateMaybeMessage<GameStart>(nullptr);
  }

  GameStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameStart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameStart& from);
  void MergeFrom(const GameStart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameStart";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 3,
    kStateFieldNumber = 2,
    kColorFieldNumber = 1,
  };
  // string gameId = 3;
  void clear_gameid();
  const std::string& gameid() const;
  void set_gameid(const std::string& value);
  void set_gameid(std::string&& value);
  void set_gameid(const char* value);
  void set_gameid(const char* value, size_t size);
  std::string* mutable_gameid();
  std::string* release_gameid();
  void set_allocated_gameid(std::string* gameid);
  private:
  const std::string& _internal_gameid() const;
  void _internal_set_gameid(const std::string& value);
  std::string* _internal_mutable_gameid();
  public:

  // .GrpcGameService.GameState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::GrpcGameService::GameState& state() const;
  ::GrpcGameService::GameState* release_state();
  ::GrpcGameService::GameState* mutable_state();
  void set_allocated_state(::GrpcGameService::GameState* state);
  private:
  const ::GrpcGameService::GameState& _internal_state() const;
  ::GrpcGameService::GameState* _internal_mutable_state();
  public:

  // .GrpcGameService.Color color = 1;
  void clear_color();
  ::GrpcGameService::Color color() const;
  void set_color(::GrpcGameService::Color value);
  private:
  ::GrpcGameService::Color _internal_color() const;
  void _internal_set_color(::GrpcGameService::Color value);
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.GameStart)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameid_;
  ::GrpcGameService::GameState* state_;
  int color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class GameEnd :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.GameEnd) */ {
 public:
  GameEnd();
  virtual ~GameEnd();

  GameEnd(const GameEnd& from);
  GameEnd(GameEnd&& from) noexcept
    : GameEnd() {
    *this = ::std::move(from);
  }

  inline GameEnd& operator=(const GameEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEnd& operator=(GameEnd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEnd& default_instance();

  enum TypOfEndCase {
    kWin = 1,
    kAbandon = 2,
    kDraw = 3,
    TYPOFEND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEnd* internal_default_instance() {
    return reinterpret_cast<const GameEnd*>(
               &_GameEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GameEnd& a, GameEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEnd* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEnd* New() const final {
    return CreateMaybeMessage<GameEnd>(nullptr);
  }

  GameEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEnd>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEnd& from);
  void MergeFrom(const GameEnd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEnd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.GameEnd";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinFieldNumber = 1,
    kAbandonFieldNumber = 2,
    kDrawFieldNumber = 3,
  };
  // .GrpcGameService.Color win = 1;
  private:
  bool _internal_has_win() const;
  public:
  void clear_win();
  ::GrpcGameService::Color win() const;
  void set_win(::GrpcGameService::Color value);
  private:
  ::GrpcGameService::Color _internal_win() const;
  void _internal_set_win(::GrpcGameService::Color value);
  public:

  // .GrpcGameService.Color abandon = 2;
  private:
  bool _internal_has_abandon() const;
  public:
  void clear_abandon();
  ::GrpcGameService::Color abandon() const;
  void set_abandon(::GrpcGameService::Color value);
  private:
  ::GrpcGameService::Color _internal_abandon() const;
  void _internal_set_abandon(::GrpcGameService::Color value);
  public:

  // bool draw = 3;
  private:
  bool _internal_has_draw() const;
  public:
  void clear_draw();
  bool draw() const;
  void set_draw(bool value);
  private:
  bool _internal_draw() const;
  void _internal_set_draw(bool value);
  public:

  void clear_TypOfEnd();
  TypOfEndCase TypOfEnd_case() const;
  // @@protoc_insertion_point(class_scope:GrpcGameService.GameEnd)
 private:
  class _Internal;
  void set_has_win();
  void set_has_abandon();
  void set_has_draw();

  inline bool has_TypOfEnd() const;
  inline void clear_has_TypOfEnd();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union TypOfEndUnion {
    TypOfEndUnion() {}
    int win_;
    int abandon_;
    bool draw_;
  } TypOfEnd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_GameService_2eproto;
};
// -------------------------------------------------------------------

class Room :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GrpcGameService.Room) */ {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);
  Room(Room&& from) noexcept
    : Room() {
    *this = ::std::move(from);
  }

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Room* internal_default_instance() {
    return reinterpret_cast<const Room*>(
               &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Room& a, Room& b) {
    a.Swap(&b);
  }
  inline void Swap(Room* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Room* New() const final {
    return CreateMaybeMessage<Room>(nullptr);
  }

  Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Room>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GrpcGameService.Room";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_GameService_2eproto);
    return ::descriptor_table_GameService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRoomIdFieldNumber = 1,
    kPlayerCountFieldNumber = 3,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 RoomId = 1;
  void clear_roomid();
  ::PROTOBUF_NAMESPACE_ID::int32 roomid() const;
  void set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roomid() const;
  void _internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 PlayerCount = 3;
  void clear_playercount();
  ::PROTOBUF_NAMESPACE_ID::int32 playercount() const;
  void set_playercount(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playercount() const;
  void _internal_set_playercount(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GrpcGameService.Room)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomid_;
  ::PROTOBUF_NAMESPACE_ID::int32 playercount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoomListRequest

// -------------------------------------------------------------------

// RoomListResponse

// repeated .GrpcGameService.Room rooms = 1;
inline int RoomListResponse::_internal_rooms_size() const {
  return rooms_.size();
}
inline int RoomListResponse::rooms_size() const {
  return _internal_rooms_size();
}
inline void RoomListResponse::clear_rooms() {
  rooms_.Clear();
}
inline ::GrpcGameService::Room* RoomListResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.RoomListResponse.rooms)
  return rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::Room >*
RoomListResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:GrpcGameService.RoomListResponse.rooms)
  return &rooms_;
}
inline const ::GrpcGameService::Room& RoomListResponse::_internal_rooms(int index) const {
  return rooms_.Get(index);
}
inline const ::GrpcGameService::Room& RoomListResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:GrpcGameService.RoomListResponse.rooms)
  return _internal_rooms(index);
}
inline ::GrpcGameService::Room* RoomListResponse::_internal_add_rooms() {
  return rooms_.Add();
}
inline ::GrpcGameService::Room* RoomListResponse::add_rooms() {
  // @@protoc_insertion_point(field_add:GrpcGameService.RoomListResponse.rooms)
  return _internal_add_rooms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::Room >&
RoomListResponse::rooms() const {
  // @@protoc_insertion_point(field_list:GrpcGameService.RoomListResponse.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// RoomCreateRequest

// string name = 1;
inline void RoomCreateRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoomCreateRequest::name() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.RoomCreateRequest.name)
  return _internal_name();
}
inline void RoomCreateRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.RoomCreateRequest.name)
}
inline std::string* RoomCreateRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.RoomCreateRequest.name)
  return _internal_mutable_name();
}
inline const std::string& RoomCreateRequest::_internal_name() const {
  return name_.GetNoArena();
}
inline void RoomCreateRequest::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoomCreateRequest::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GrpcGameService.RoomCreateRequest.name)
}
inline void RoomCreateRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GrpcGameService.RoomCreateRequest.name)
}
inline void RoomCreateRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GrpcGameService.RoomCreateRequest.name)
}
inline std::string* RoomCreateRequest::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoomCreateRequest::release_name() {
  // @@protoc_insertion_point(field_release:GrpcGameService.RoomCreateRequest.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoomCreateRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.RoomCreateRequest.name)
}

// -------------------------------------------------------------------

// RoomCreateResponse

// .GrpcGameService.Room room = 1;
inline bool RoomCreateResponse::_internal_has_room() const {
  return this != internal_default_instance() && room_ != nullptr;
}
inline bool RoomCreateResponse::has_room() const {
  return _internal_has_room();
}
inline void RoomCreateResponse::clear_room() {
  if (GetArenaNoVirtual() == nullptr && room_ != nullptr) {
    delete room_;
  }
  room_ = nullptr;
}
inline const ::GrpcGameService::Room& RoomCreateResponse::_internal_room() const {
  const ::GrpcGameService::Room* p = room_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::Room*>(
      &::GrpcGameService::_Room_default_instance_);
}
inline const ::GrpcGameService::Room& RoomCreateResponse::room() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.RoomCreateResponse.room)
  return _internal_room();
}
inline ::GrpcGameService::Room* RoomCreateResponse::release_room() {
  // @@protoc_insertion_point(field_release:GrpcGameService.RoomCreateResponse.room)
  
  ::GrpcGameService::Room* temp = room_;
  room_ = nullptr;
  return temp;
}
inline ::GrpcGameService::Room* RoomCreateResponse::_internal_mutable_room() {
  
  if (room_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::Room>(GetArenaNoVirtual());
    room_ = p;
  }
  return room_;
}
inline ::GrpcGameService::Room* RoomCreateResponse::mutable_room() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.RoomCreateResponse.room)
  return _internal_mutable_room();
}
inline void RoomCreateResponse::set_allocated_room(::GrpcGameService::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete room_;
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.RoomCreateResponse.room)
}

// -------------------------------------------------------------------

// RoomJoinRequest

// .GrpcGameService.Room room = 1;
inline bool RoomJoinRequest::_internal_has_room() const {
  return this != internal_default_instance() && room_ != nullptr;
}
inline bool RoomJoinRequest::has_room() const {
  return _internal_has_room();
}
inline void RoomJoinRequest::clear_room() {
  if (GetArenaNoVirtual() == nullptr && room_ != nullptr) {
    delete room_;
  }
  room_ = nullptr;
}
inline const ::GrpcGameService::Room& RoomJoinRequest::_internal_room() const {
  const ::GrpcGameService::Room* p = room_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::Room*>(
      &::GrpcGameService::_Room_default_instance_);
}
inline const ::GrpcGameService::Room& RoomJoinRequest::room() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.RoomJoinRequest.room)
  return _internal_room();
}
inline ::GrpcGameService::Room* RoomJoinRequest::release_room() {
  // @@protoc_insertion_point(field_release:GrpcGameService.RoomJoinRequest.room)
  
  ::GrpcGameService::Room* temp = room_;
  room_ = nullptr;
  return temp;
}
inline ::GrpcGameService::Room* RoomJoinRequest::_internal_mutable_room() {
  
  if (room_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::Room>(GetArenaNoVirtual());
    room_ = p;
  }
  return room_;
}
inline ::GrpcGameService::Room* RoomJoinRequest::mutable_room() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.RoomJoinRequest.room)
  return _internal_mutable_room();
}
inline void RoomJoinRequest::set_allocated_room(::GrpcGameService::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete room_;
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.RoomJoinRequest.room)
}

// -------------------------------------------------------------------

// GameMoveRequest

// .GrpcGameService.GameMove move = 1;
inline bool GameMoveRequest::_internal_has_move() const {
  return this != internal_default_instance() && move_ != nullptr;
}
inline bool GameMoveRequest::has_move() const {
  return _internal_has_move();
}
inline void GameMoveRequest::clear_move() {
  if (GetArenaNoVirtual() == nullptr && move_ != nullptr) {
    delete move_;
  }
  move_ = nullptr;
}
inline const ::GrpcGameService::GameMove& GameMoveRequest::_internal_move() const {
  const ::GrpcGameService::GameMove* p = move_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::GameMove*>(
      &::GrpcGameService::_GameMove_default_instance_);
}
inline const ::GrpcGameService::GameMove& GameMoveRequest::move() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameMoveRequest.move)
  return _internal_move();
}
inline ::GrpcGameService::GameMove* GameMoveRequest::release_move() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameMoveRequest.move)
  
  ::GrpcGameService::GameMove* temp = move_;
  move_ = nullptr;
  return temp;
}
inline ::GrpcGameService::GameMove* GameMoveRequest::_internal_mutable_move() {
  
  if (move_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::GameMove>(GetArenaNoVirtual());
    move_ = p;
  }
  return move_;
}
inline ::GrpcGameService::GameMove* GameMoveRequest::mutable_move() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameMoveRequest.move)
  return _internal_mutable_move();
}
inline void GameMoveRequest::set_allocated_move(::GrpcGameService::GameMove* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete move_;
  }
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    
  } else {
    
  }
  move_ = move;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameMoveRequest.move)
}

// string gameId = 2;
inline void GameMoveRequest::clear_gameid() {
  gameid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameMoveRequest::gameid() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameMoveRequest.gameId)
  return _internal_gameid();
}
inline void GameMoveRequest::set_gameid(const std::string& value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameMoveRequest.gameId)
}
inline std::string* GameMoveRequest::mutable_gameid() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameMoveRequest.gameId)
  return _internal_mutable_gameid();
}
inline const std::string& GameMoveRequest::_internal_gameid() const {
  return gameid_.GetNoArena();
}
inline void GameMoveRequest::_internal_set_gameid(const std::string& value) {
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameMoveRequest::set_gameid(std::string&& value) {
  
  gameid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GrpcGameService.GameMoveRequest.gameId)
}
inline void GameMoveRequest::set_gameid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GrpcGameService.GameMoveRequest.gameId)
}
inline void GameMoveRequest::set_gameid(const char* value, size_t size) {
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GrpcGameService.GameMoveRequest.gameId)
}
inline std::string* GameMoveRequest::_internal_mutable_gameid() {
  
  return gameid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameMoveRequest::release_gameid() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameMoveRequest.gameId)
  
  return gameid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameMoveRequest::set_allocated_gameid(std::string* gameid) {
  if (gameid != nullptr) {
    
  } else {
    
  }
  gameid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameid);
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameMoveRequest.gameId)
}

// -------------------------------------------------------------------

// GameMoveResponse

// bool valid = 1;
inline void GameMoveResponse::clear_valid() {
  valid_ = false;
}
inline bool GameMoveResponse::_internal_valid() const {
  return valid_;
}
inline bool GameMoveResponse::valid() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameMoveResponse.valid)
  return _internal_valid();
}
inline void GameMoveResponse::_internal_set_valid(bool value) {
  
  valid_ = value;
}
inline void GameMoveResponse::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameMoveResponse.valid)
}

// -------------------------------------------------------------------

// GameCommandResponse

// .GrpcGameService.GameMove move = 1;
inline bool GameCommandResponse::_internal_has_move() const {
  return Commands_case() == kMove;
}
inline bool GameCommandResponse::has_move() const {
  return _internal_has_move();
}
inline void GameCommandResponse::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void GameCommandResponse::clear_move() {
  if (_internal_has_move()) {
    delete Commands_.move_;
    clear_has_Commands();
  }
}
inline ::GrpcGameService::GameMove* GameCommandResponse::release_move() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameCommandResponse.move)
  if (_internal_has_move()) {
    clear_has_Commands();
      ::GrpcGameService::GameMove* temp = Commands_.move_;
    Commands_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GrpcGameService::GameMove& GameCommandResponse::_internal_move() const {
  return _internal_has_move()
      ? *Commands_.move_
      : *reinterpret_cast< ::GrpcGameService::GameMove*>(&::GrpcGameService::_GameMove_default_instance_);
}
inline const ::GrpcGameService::GameMove& GameCommandResponse::move() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameCommandResponse.move)
  return _internal_move();
}
inline ::GrpcGameService::GameMove* GameCommandResponse::_internal_mutable_move() {
  if (!_internal_has_move()) {
    clear_Commands();
    set_has_move();
    Commands_.move_ = CreateMaybeMessage< ::GrpcGameService::GameMove >(
        GetArenaNoVirtual());
  }
  return Commands_.move_;
}
inline ::GrpcGameService::GameMove* GameCommandResponse::mutable_move() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameCommandResponse.move)
  return _internal_mutable_move();
}

// .GrpcGameService.GameStart start = 2;
inline bool GameCommandResponse::_internal_has_start() const {
  return Commands_case() == kStart;
}
inline bool GameCommandResponse::has_start() const {
  return _internal_has_start();
}
inline void GameCommandResponse::set_has_start() {
  _oneof_case_[0] = kStart;
}
inline void GameCommandResponse::clear_start() {
  if (_internal_has_start()) {
    delete Commands_.start_;
    clear_has_Commands();
  }
}
inline ::GrpcGameService::GameStart* GameCommandResponse::release_start() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameCommandResponse.start)
  if (_internal_has_start()) {
    clear_has_Commands();
      ::GrpcGameService::GameStart* temp = Commands_.start_;
    Commands_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GrpcGameService::GameStart& GameCommandResponse::_internal_start() const {
  return _internal_has_start()
      ? *Commands_.start_
      : *reinterpret_cast< ::GrpcGameService::GameStart*>(&::GrpcGameService::_GameStart_default_instance_);
}
inline const ::GrpcGameService::GameStart& GameCommandResponse::start() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameCommandResponse.start)
  return _internal_start();
}
inline ::GrpcGameService::GameStart* GameCommandResponse::_internal_mutable_start() {
  if (!_internal_has_start()) {
    clear_Commands();
    set_has_start();
    Commands_.start_ = CreateMaybeMessage< ::GrpcGameService::GameStart >(
        GetArenaNoVirtual());
  }
  return Commands_.start_;
}
inline ::GrpcGameService::GameStart* GameCommandResponse::mutable_start() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameCommandResponse.start)
  return _internal_mutable_start();
}

// .GrpcGameService.GameEnd end = 3;
inline bool GameCommandResponse::_internal_has_end() const {
  return Commands_case() == kEnd;
}
inline bool GameCommandResponse::has_end() const {
  return _internal_has_end();
}
inline void GameCommandResponse::set_has_end() {
  _oneof_case_[0] = kEnd;
}
inline void GameCommandResponse::clear_end() {
  if (_internal_has_end()) {
    delete Commands_.end_;
    clear_has_Commands();
  }
}
inline ::GrpcGameService::GameEnd* GameCommandResponse::release_end() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameCommandResponse.end)
  if (_internal_has_end()) {
    clear_has_Commands();
      ::GrpcGameService::GameEnd* temp = Commands_.end_;
    Commands_.end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GrpcGameService::GameEnd& GameCommandResponse::_internal_end() const {
  return _internal_has_end()
      ? *Commands_.end_
      : *reinterpret_cast< ::GrpcGameService::GameEnd*>(&::GrpcGameService::_GameEnd_default_instance_);
}
inline const ::GrpcGameService::GameEnd& GameCommandResponse::end() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameCommandResponse.end)
  return _internal_end();
}
inline ::GrpcGameService::GameEnd* GameCommandResponse::_internal_mutable_end() {
  if (!_internal_has_end()) {
    clear_Commands();
    set_has_end();
    Commands_.end_ = CreateMaybeMessage< ::GrpcGameService::GameEnd >(
        GetArenaNoVirtual());
  }
  return Commands_.end_;
}
inline ::GrpcGameService::GameEnd* GameCommandResponse::mutable_end() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameCommandResponse.end)
  return _internal_mutable_end();
}

inline bool GameCommandResponse::has_Commands() const {
  return Commands_case() != COMMANDS_NOT_SET;
}
inline void GameCommandResponse::clear_has_Commands() {
  _oneof_case_[0] = COMMANDS_NOT_SET;
}
inline GameCommandResponse::CommandsCase GameCommandResponse::Commands_case() const {
  return GameCommandResponse::CommandsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Position

// int32 column = 1;
inline void Position::clear_column() {
  column_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Position::_internal_column() const {
  return column_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Position::column() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.Position.column)
  return _internal_column();
}
inline void Position::_internal_set_column(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  column_ = value;
}
inline void Position::set_column(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_column(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.Position.column)
}

// int32 row = 2;
inline void Position::clear_row() {
  row_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Position::_internal_row() const {
  return row_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Position::row() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.Position.row)
  return _internal_row();
}
inline void Position::_internal_set_row(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  row_ = value;
}
inline void Position::set_row(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_row(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.Position.row)
}

// -------------------------------------------------------------------

// GameMove

// .GrpcGameService.Position from = 1;
inline bool GameMove::_internal_has_from() const {
  return this != internal_default_instance() && from_ != nullptr;
}
inline bool GameMove::has_from() const {
  return _internal_has_from();
}
inline void GameMove::clear_from() {
  if (GetArenaNoVirtual() == nullptr && from_ != nullptr) {
    delete from_;
  }
  from_ = nullptr;
}
inline const ::GrpcGameService::Position& GameMove::_internal_from() const {
  const ::GrpcGameService::Position* p = from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::Position*>(
      &::GrpcGameService::_Position_default_instance_);
}
inline const ::GrpcGameService::Position& GameMove::from() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameMove.from)
  return _internal_from();
}
inline ::GrpcGameService::Position* GameMove::release_from() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameMove.from)
  
  ::GrpcGameService::Position* temp = from_;
  from_ = nullptr;
  return temp;
}
inline ::GrpcGameService::Position* GameMove::_internal_mutable_from() {
  
  if (from_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::Position>(GetArenaNoVirtual());
    from_ = p;
  }
  return from_;
}
inline ::GrpcGameService::Position* GameMove::mutable_from() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameMove.from)
  return _internal_mutable_from();
}
inline void GameMove::set_allocated_from(::GrpcGameService::Position* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameMove.from)
}

// .GrpcGameService.Position to = 2;
inline bool GameMove::_internal_has_to() const {
  return this != internal_default_instance() && to_ != nullptr;
}
inline bool GameMove::has_to() const {
  return _internal_has_to();
}
inline void GameMove::clear_to() {
  if (GetArenaNoVirtual() == nullptr && to_ != nullptr) {
    delete to_;
  }
  to_ = nullptr;
}
inline const ::GrpcGameService::Position& GameMove::_internal_to() const {
  const ::GrpcGameService::Position* p = to_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::Position*>(
      &::GrpcGameService::_Position_default_instance_);
}
inline const ::GrpcGameService::Position& GameMove::to() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameMove.to)
  return _internal_to();
}
inline ::GrpcGameService::Position* GameMove::release_to() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameMove.to)
  
  ::GrpcGameService::Position* temp = to_;
  to_ = nullptr;
  return temp;
}
inline ::GrpcGameService::Position* GameMove::_internal_mutable_to() {
  
  if (to_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::Position>(GetArenaNoVirtual());
    to_ = p;
  }
  return to_;
}
inline ::GrpcGameService::Position* GameMove::mutable_to() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameMove.to)
  return _internal_mutable_to();
}
inline void GameMove::set_allocated_to(::GrpcGameService::Position* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  to_ = to;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameMove.to)
}

// -------------------------------------------------------------------

// GameTile

// .GrpcGameService.Figurine figurine = 1;
inline void GameTile::clear_figurine() {
  figurine_ = 0;
}
inline ::GrpcGameService::Figurine GameTile::_internal_figurine() const {
  return static_cast< ::GrpcGameService::Figurine >(figurine_);
}
inline ::GrpcGameService::Figurine GameTile::figurine() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameTile.figurine)
  return _internal_figurine();
}
inline void GameTile::_internal_set_figurine(::GrpcGameService::Figurine value) {
  
  figurine_ = value;
}
inline void GameTile::set_figurine(::GrpcGameService::Figurine value) {
  _internal_set_figurine(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameTile.figurine)
}

// .GrpcGameService.Color figurineColor = 2;
inline void GameTile::clear_figurinecolor() {
  figurinecolor_ = 0;
}
inline ::GrpcGameService::Color GameTile::_internal_figurinecolor() const {
  return static_cast< ::GrpcGameService::Color >(figurinecolor_);
}
inline ::GrpcGameService::Color GameTile::figurinecolor() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameTile.figurineColor)
  return _internal_figurinecolor();
}
inline void GameTile::_internal_set_figurinecolor(::GrpcGameService::Color value) {
  
  figurinecolor_ = value;
}
inline void GameTile::set_figurinecolor(::GrpcGameService::Color value) {
  _internal_set_figurinecolor(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameTile.figurineColor)
}

// .GrpcGameService.Position position = 3;
inline bool GameTile::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameTile::has_position() const {
  return _internal_has_position();
}
inline void GameTile::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::GrpcGameService::Position& GameTile::_internal_position() const {
  const ::GrpcGameService::Position* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::Position*>(
      &::GrpcGameService::_Position_default_instance_);
}
inline const ::GrpcGameService::Position& GameTile::position() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameTile.position)
  return _internal_position();
}
inline ::GrpcGameService::Position* GameTile::release_position() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameTile.position)
  
  ::GrpcGameService::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::GrpcGameService::Position* GameTile::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::GrpcGameService::Position* GameTile::mutable_position() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameTile.position)
  return _internal_mutable_position();
}
inline void GameTile::set_allocated_position(::GrpcGameService::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameTile.position)
}

// -------------------------------------------------------------------

// GameState

// repeated .GrpcGameService.GameTile tiles = 1;
inline int GameState::_internal_tiles_size() const {
  return tiles_.size();
}
inline int GameState::tiles_size() const {
  return _internal_tiles_size();
}
inline void GameState::clear_tiles() {
  tiles_.Clear();
}
inline ::GrpcGameService::GameTile* GameState::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameState.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::GameTile >*
GameState::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:GrpcGameService.GameState.tiles)
  return &tiles_;
}
inline const ::GrpcGameService::GameTile& GameState::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::GrpcGameService::GameTile& GameState::tiles(int index) const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameState.tiles)
  return _internal_tiles(index);
}
inline ::GrpcGameService::GameTile* GameState::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::GrpcGameService::GameTile* GameState::add_tiles() {
  // @@protoc_insertion_point(field_add:GrpcGameService.GameState.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GrpcGameService::GameTile >&
GameState::tiles() const {
  // @@protoc_insertion_point(field_list:GrpcGameService.GameState.tiles)
  return tiles_;
}

// -------------------------------------------------------------------

// GameStart

// .GrpcGameService.Color color = 1;
inline void GameStart::clear_color() {
  color_ = 0;
}
inline ::GrpcGameService::Color GameStart::_internal_color() const {
  return static_cast< ::GrpcGameService::Color >(color_);
}
inline ::GrpcGameService::Color GameStart::color() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameStart.color)
  return _internal_color();
}
inline void GameStart::_internal_set_color(::GrpcGameService::Color value) {
  
  color_ = value;
}
inline void GameStart::set_color(::GrpcGameService::Color value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameStart.color)
}

// .GrpcGameService.GameState state = 2;
inline bool GameStart::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool GameStart::has_state() const {
  return _internal_has_state();
}
inline void GameStart::clear_state() {
  if (GetArenaNoVirtual() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::GrpcGameService::GameState& GameStart::_internal_state() const {
  const ::GrpcGameService::GameState* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GrpcGameService::GameState*>(
      &::GrpcGameService::_GameState_default_instance_);
}
inline const ::GrpcGameService::GameState& GameStart::state() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameStart.state)
  return _internal_state();
}
inline ::GrpcGameService::GameState* GameStart::release_state() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameStart.state)
  
  ::GrpcGameService::GameState* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::GrpcGameService::GameState* GameStart::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcGameService::GameState>(GetArenaNoVirtual());
    state_ = p;
  }
  return state_;
}
inline ::GrpcGameService::GameState* GameStart::mutable_state() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameStart.state)
  return _internal_mutable_state();
}
inline void GameStart::set_allocated_state(::GrpcGameService::GameState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameStart.state)
}

// string gameId = 3;
inline void GameStart::clear_gameid() {
  gameid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameStart::gameid() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameStart.gameId)
  return _internal_gameid();
}
inline void GameStart::set_gameid(const std::string& value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameStart.gameId)
}
inline std::string* GameStart::mutable_gameid() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.GameStart.gameId)
  return _internal_mutable_gameid();
}
inline const std::string& GameStart::_internal_gameid() const {
  return gameid_.GetNoArena();
}
inline void GameStart::_internal_set_gameid(const std::string& value) {
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameStart::set_gameid(std::string&& value) {
  
  gameid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GrpcGameService.GameStart.gameId)
}
inline void GameStart::set_gameid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GrpcGameService.GameStart.gameId)
}
inline void GameStart::set_gameid(const char* value, size_t size) {
  
  gameid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GrpcGameService.GameStart.gameId)
}
inline std::string* GameStart::_internal_mutable_gameid() {
  
  return gameid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameStart::release_gameid() {
  // @@protoc_insertion_point(field_release:GrpcGameService.GameStart.gameId)
  
  return gameid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameStart::set_allocated_gameid(std::string* gameid) {
  if (gameid != nullptr) {
    
  } else {
    
  }
  gameid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameid);
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.GameStart.gameId)
}

// -------------------------------------------------------------------

// GameEnd

// .GrpcGameService.Color win = 1;
inline bool GameEnd::_internal_has_win() const {
  return TypOfEnd_case() == kWin;
}
inline void GameEnd::set_has_win() {
  _oneof_case_[0] = kWin;
}
inline void GameEnd::clear_win() {
  if (_internal_has_win()) {
    TypOfEnd_.win_ = 0;
    clear_has_TypOfEnd();
  }
}
inline ::GrpcGameService::Color GameEnd::_internal_win() const {
  if (_internal_has_win()) {
    return static_cast< ::GrpcGameService::Color >(TypOfEnd_.win_);
  }
  return static_cast< ::GrpcGameService::Color >(0);
}
inline ::GrpcGameService::Color GameEnd::win() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameEnd.win)
  return _internal_win();
}
inline void GameEnd::_internal_set_win(::GrpcGameService::Color value) {
  if (!_internal_has_win()) {
    clear_TypOfEnd();
    set_has_win();
  }
  TypOfEnd_.win_ = value;
}
inline void GameEnd::set_win(::GrpcGameService::Color value) {
  // @@protoc_insertion_point(field_set:GrpcGameService.GameEnd.win)
  _internal_set_win(value);
}

// .GrpcGameService.Color abandon = 2;
inline bool GameEnd::_internal_has_abandon() const {
  return TypOfEnd_case() == kAbandon;
}
inline void GameEnd::set_has_abandon() {
  _oneof_case_[0] = kAbandon;
}
inline void GameEnd::clear_abandon() {
  if (_internal_has_abandon()) {
    TypOfEnd_.abandon_ = 0;
    clear_has_TypOfEnd();
  }
}
inline ::GrpcGameService::Color GameEnd::_internal_abandon() const {
  if (_internal_has_abandon()) {
    return static_cast< ::GrpcGameService::Color >(TypOfEnd_.abandon_);
  }
  return static_cast< ::GrpcGameService::Color >(0);
}
inline ::GrpcGameService::Color GameEnd::abandon() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameEnd.abandon)
  return _internal_abandon();
}
inline void GameEnd::_internal_set_abandon(::GrpcGameService::Color value) {
  if (!_internal_has_abandon()) {
    clear_TypOfEnd();
    set_has_abandon();
  }
  TypOfEnd_.abandon_ = value;
}
inline void GameEnd::set_abandon(::GrpcGameService::Color value) {
  // @@protoc_insertion_point(field_set:GrpcGameService.GameEnd.abandon)
  _internal_set_abandon(value);
}

// bool draw = 3;
inline bool GameEnd::_internal_has_draw() const {
  return TypOfEnd_case() == kDraw;
}
inline void GameEnd::set_has_draw() {
  _oneof_case_[0] = kDraw;
}
inline void GameEnd::clear_draw() {
  if (_internal_has_draw()) {
    TypOfEnd_.draw_ = false;
    clear_has_TypOfEnd();
  }
}
inline bool GameEnd::_internal_draw() const {
  if (_internal_has_draw()) {
    return TypOfEnd_.draw_;
  }
  return false;
}
inline void GameEnd::_internal_set_draw(bool value) {
  if (!_internal_has_draw()) {
    clear_TypOfEnd();
    set_has_draw();
  }
  TypOfEnd_.draw_ = value;
}
inline bool GameEnd::draw() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.GameEnd.draw)
  return _internal_draw();
}
inline void GameEnd::set_draw(bool value) {
  _internal_set_draw(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.GameEnd.draw)
}

inline bool GameEnd::has_TypOfEnd() const {
  return TypOfEnd_case() != TYPOFEND_NOT_SET;
}
inline void GameEnd::clear_has_TypOfEnd() {
  _oneof_case_[0] = TYPOFEND_NOT_SET;
}
inline GameEnd::TypOfEndCase GameEnd::TypOfEnd_case() const {
  return GameEnd::TypOfEndCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Room

// int32 RoomId = 1;
inline void Room::clear_roomid() {
  roomid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Room::_internal_roomid() const {
  return roomid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Room::roomid() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.Room.RoomId)
  return _internal_roomid();
}
inline void Room::_internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  roomid_ = value;
}
inline void Room::set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.Room.RoomId)
}

// string Name = 2;
inline void Room::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Room::name() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.Room.Name)
  return _internal_name();
}
inline void Room::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.Room.Name)
}
inline std::string* Room::mutable_name() {
  // @@protoc_insertion_point(field_mutable:GrpcGameService.Room.Name)
  return _internal_mutable_name();
}
inline const std::string& Room::_internal_name() const {
  return name_.GetNoArena();
}
inline void Room::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Room::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GrpcGameService.Room.Name)
}
inline void Room::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GrpcGameService.Room.Name)
}
inline void Room::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GrpcGameService.Room.Name)
}
inline std::string* Room::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Room::release_name() {
  // @@protoc_insertion_point(field_release:GrpcGameService.Room.Name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Room::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GrpcGameService.Room.Name)
}

// int32 PlayerCount = 3;
inline void Room::clear_playercount() {
  playercount_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Room::_internal_playercount() const {
  return playercount_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Room::playercount() const {
  // @@protoc_insertion_point(field_get:GrpcGameService.Room.PlayerCount)
  return _internal_playercount();
}
inline void Room::_internal_set_playercount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playercount_ = value;
}
inline void Room::set_playercount(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playercount(value);
  // @@protoc_insertion_point(field_set:GrpcGameService.Room.PlayerCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GrpcGameService

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GrpcGameService::Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GrpcGameService::Color>() {
  return ::GrpcGameService::Color_descriptor();
}
template <> struct is_proto_enum< ::GrpcGameService::Figurine> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GrpcGameService::Figurine>() {
  return ::GrpcGameService::Figurine_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GameService_2eproto
